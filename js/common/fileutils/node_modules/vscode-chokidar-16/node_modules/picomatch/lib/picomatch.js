"use strict";const path=require("path"),scan=require("./scan"),parse=require("./parse"),utils=require("./utils"),constants=require("./constants"),isObject=t=>t&&"object"==typeof t&&!Array.isArray(t),picomatch=(t,e,o=!1)=>{if(Array.isArray(t)){const a=t.map((t=>picomatch(t,e,o))),c=t=>{for(const e of a){const o=e(t);if(o)return o}return!1};return c}const a=(c=t)&&"object"==typeof c&&!Array.isArray(c)&&t.tokens&&t.input;var c;if(""===t||"string"!=typeof t&&!a)throw new TypeError("Expected pattern to be a non-empty string");const s=e||{},n=utils.isWindows(e),r=a?picomatch.compileRe(t,e):picomatch.makeRe(t,e,!1,!0),i=r.state;delete r.state;let p=()=>!1;if(s.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};p=picomatch(s.ignore,t,o)}const u=(o,a=!1)=>{const{isMatch:c,match:u,output:h}=picomatch.test(o,r,e,{glob:t,posix:n}),m={glob:t,state:i,regex:r,posix:n,input:o,output:h,match:u,isMatch:c};return"function"==typeof s.onResult&&s.onResult(m),!1===c?(m.isMatch=!1,!!a&&m):p(o)?("function"==typeof s.onIgnore&&s.onIgnore(m),m.isMatch=!1,!!a&&m):("function"==typeof s.onMatch&&s.onMatch(m),!a||m)};return o&&(u.state=i),u};picomatch.test=(t,e,o,{glob:a,posix:c}={})=>{if("string"!=typeof t)throw new TypeError("Expected input to be a string");if(""===t)return{isMatch:!1,output:""};const s=o||{},n=s.format||(c?utils.toPosixSlashes:null);let r=t===a,i=r&&n?n(t):t;return!1===r&&(i=n?n(t):t,r=i===a),!1!==r&&!0!==s.capture||(r=!0===s.matchBase||!0===s.basename?picomatch.matchBase(t,e,o,c):e.exec(i)),{isMatch:Boolean(r),match:r,output:i}},picomatch.matchBase=(t,e,o,a=utils.isWindows(o))=>(e instanceof RegExp?e:picomatch.makeRe(e,o)).test(path.basename(t)),picomatch.isMatch=(t,e,o)=>picomatch(e,o)(t),picomatch.parse=(t,e)=>Array.isArray(t)?t.map((t=>picomatch.parse(t,e))):parse(t,{...e,fastpaths:!1}),picomatch.scan=(t,e)=>scan(t,e),picomatch.compileRe=(t,e,o=!1,a=!1)=>{if(!0===o)return t.output;const c=e||{},s=c.contains?"":"^",n=c.contains?"":"$";let r=`${s}(?:${t.output})${n}`;t&&!0===t.negated&&(r=`^(?!${r}).*$`);const i=picomatch.toRegex(r,e);return!0===a&&(i.state=t),i},picomatch.makeRe=(t,e={},o=!1,a=!1)=>{if(!t||"string"!=typeof t)throw new TypeError("Expected a non-empty string");let c={negated:!1,fastpaths:!0};return!1===e.fastpaths||"."!==t[0]&&"*"!==t[0]||(c.output=parse.fastpaths(t,e)),c.output||(c=parse(t,e)),picomatch.compileRe(c,e,o,a)},picomatch.toRegex=(t,e)=>{try{const o=e||{};return new RegExp(t,o.flags||(o.nocase?"i":""))}catch(t){if(e&&!0===e.debug)throw t;return/$^/}},picomatch.constants=constants,module.exports=picomatch;
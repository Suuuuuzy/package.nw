{"version":3,"file":"index.js","mappings":"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","sources":["webpack://wechat-miniprogram-development/./src/index.ts","webpack://wechat-miniprogram-development/./src/languageService.ts","webpack://wechat-miniprogram-development/./src/utils/fs.ts","webpack://wechat-miniprogram-development/./src/utils/utils.ts","webpack://wechat-miniprogram-development/external node-commonjs \"path\"","webpack://wechat-miniprogram-development/webpack/bootstrap","webpack://wechat-miniprogram-development/webpack/startup"],"sourcesContent":["/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport * as ts from 'typescript/lib/tsserverlibrary'\nimport * as path from 'path'\nimport { MiniProgramTypeScriptLanguageService } from './languageService'\nimport { FSManager } from './utils/fs'\nimport { normalizePath } from './utils/utils'\nconst tsConfigMap: Map<string, ITransformedTSConfig> = new Map()\n\n/**\n * get raw tsconfig content from tsconfig.json\n */\nfunction getRawTSConfig (info: ts.server.PluginCreateInfo, tsConfigMap: Map<string, ITransformedTSConfig>, fs: FSManager): void {\n  const currentTSConfigPath = normalizePath(path.join(info.project.getCurrentDirectory(), 'tsconfig.json'))\n  if (tsConfigMap.has(currentTSConfigPath)) {\n    return\n  }\n  const tsConfig = fs.readTSConfig(currentTSConfigPath) as ITransformedTSConfig['raw']\n  if (tsConfig !== null) {\n    tsConfigMap.set(currentTSConfigPath, {\n      raw: tsConfig\n    })\n  }\n}\n\nexport = function init (modules: { typescript: typeof ts }) {\n  const ts = modules.typescript\n  ts.getDefaultCompilerOptions = () => ({\n    allowJs: true,\n    noEmit: true\n  })\n  return {\n    create (info: ts.server.PluginCreateInfo) {\n      const fsManager = new FSManager(ts)\n      const logger = info.project.projectService.logger\n      const languageService = info.languageService\n      const languageServiceHost = info.languageServiceHost\n      getRawTSConfig(info, tsConfigMap, fsManager)\n      const miniProgramTypeScriptLanguageService = new MiniProgramTypeScriptLanguageService(languageService, languageServiceHost, logger, info, ts, fsManager, tsConfigMap)\n      miniProgramTypeScriptLanguageService.init()\n      miniProgramTypeScriptLanguageService.setResolveAlias()\n      return languageService\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport * as ts from 'typescript/lib/tsserverlibrary'\nimport * as path from 'path'\nimport { FSManager } from './utils/fs'\nimport { getAbsolutePath, getTSConfigPathsRelativeConfig, normalizePath, transformResolveAliasToPaths } from './utils/utils'\nconst LOG_PREFIX = '[TypeScript MiniProgarm Plugin]'\nclass MiniProgramTypeScriptLanguageService {\n  constructor (\n    private readonly tsLS: ts.LanguageService,\n    private readonly tsLH: ts.LanguageServiceHost,\n    private readonly logger: ts.server.Logger,\n    private readonly info: ts.server.PluginCreateInfo,\n    private readonly _ts: typeof ts,\n    private readonly fs: FSManager,\n    private readonly tsConfigMap: Map<string, ITransformedTSConfig>\n  ) {\n  }\n\n  init (): void {\n    this.proxyResolveModuleNames()\n  }\n\n  /**\n   * get transformed tsconfig paths for resolveAlias\n   * if app.json has resolveAlias, we need to transform it to tsconfig paths\n   * @param tsConfigPath\n   * @returns\n   */\n  getTransformedTSConfigPaths (tsConfigPath: string): IPathsRelativeOptions {\n    const currentProjectPath = normalizePath(path.dirname(tsConfigPath))\n    let parentPaths: IPathsRelativeOptions = {\n      baseUrl: '',\n      outDir: '',\n      pathsBasePath: '',\n      projectPath: ''\n    }\n    if (this.tsConfigMap.get(tsConfigPath)?.paths !== undefined) {\n      // @ts-expect-error\n      return this.tsConfigMap.get(tsConfigPath).paths\n    }\n    let tsConfig: ITransformedTSConfig['raw'] | null\n    if (this.tsConfigMap.get(tsConfigPath)?.raw) {\n      tsConfig = this.tsConfigMap.get(tsConfigPath)?.raw\n    } else {\n      tsConfig = this.fs.readTSConfig(tsConfigPath)\n    }\n    if (!tsConfig) {\n      return parentPaths\n    }\n    if (tsConfig?.extends) {\n      parentPaths = this.getTransformedTSConfigPaths(tsConfig.extends) ?? parentPaths\n    }\n    // current baseUrl is first\n    const baseUrl = tsConfig.compilerOptions?.baseUrl\n      ? getAbsolutePath(tsConfig.compilerOptions.baseUrl, currentProjectPath)\n      : parentPaths.baseUrl ? parentPaths.baseUrl : currentProjectPath\n    // current outDir is first\n    const outDir = tsConfig.compilerOptions?.outDir\n      ? getAbsolutePath(tsConfig.compilerOptions.outDir, currentProjectPath)\n      : parentPaths.outDir ? parentPaths.outDir : normalizePath(path.join(currentProjectPath, 'dist'))\n    // if paths is not empty, pathsBasePath will be current project path\n    const pathsBasePath = tsConfig?.compilerOptions?.paths\n      ? currentProjectPath\n      : parentPaths.pathsBasePath ? parentPaths.pathsBasePath : currentProjectPath\n    const projectPath = currentProjectPath\n\n    const res = {\n      baseUrl,\n      outDir,\n      pathsBasePath,\n      projectPath\n    }\n    const tsConfigMap = this.tsConfigMap.get(tsConfigPath) ?? {}\n    tsConfigMap.paths = res\n    this.tsConfigMap.set(tsConfigPath, tsConfigMap)\n    return res\n  }\n\n  /**\n   * set miniprogram resolveAlias to tsconfig paths\n   * @returns set alias result\n   */\n  setResolveAlias (): boolean {\n    // ts project path\n    const currentProjectPath = normalizePath(this.info.project.getCurrentDirectory())\n    const currentTSConfigPaths = path.join(currentProjectPath, 'tsconfig.json')\n    const projectConfigPath = path.join(currentProjectPath, 'project.config.json')\n    const projectConfig = this.fs.readJSON<IProjectConfig>(projectConfigPath)\n    if (projectConfig !== null) {\n      const realMiniprogramRoot = path.join(\n        currentProjectPath,\n        projectConfig.srcMiniprogramRoot ?? projectConfig.miniprogramRoot ?? '.'\n      )\n      const realAppJSONPath = path.join(realMiniprogramRoot, 'app.json')\n      const appJSON = this.fs.readJSON<IAppJSON>(realAppJSONPath)\n      if (appJSON?.resolveAlias) {\n        // const originTSConfig = this.tsConfigMap.get(currentProjectPath)\n        const originCompilerOptions = this.info.project.getCompilerOptions()\n        const tsConfigPaths = this.getTransformedTSConfigPaths(currentTSConfigPaths)\n        this.logger.info(`${LOG_PREFIX} tsConfigPaths: ${JSON.stringify(tsConfigPaths, null, 2)}`)\n        const pathsRelativeConfig = getTSConfigPathsRelativeConfig(tsConfigPaths, currentProjectPath)\n        const paths = transformResolveAliasToPaths(appJSON.resolveAlias, realMiniprogramRoot, pathsRelativeConfig.baseUrl, this.logger)\n        this.logger.info(`${LOG_PREFIX} resolveAlias: ${JSON.stringify(appJSON.resolveAlias, null, 2)}`)\n        this.logger.info(`${LOG_PREFIX} paths: ${JSON.stringify(paths, null, 2)} realMiniprogramRoot: ${realMiniprogramRoot}, baseUrl: ${pathsRelativeConfig.baseUrl}`)\n        this.info.project.projectService.setCompilerOptionsForInferredProjects({\n          ...pathsRelativeConfig,\n          allowJs: true,\n          paths: {\n            ...(originCompilerOptions.paths ?? {}),\n            ...paths\n          }\n        }, currentProjectPath)\n        this.info.project.setCompilerOptions(Object.assign({}, originCompilerOptions, {\n          ...pathsRelativeConfig,\n          allowJs: true, // for pure js project\n          paths: {\n            ...(originCompilerOptions.paths ?? {}),\n            ...paths\n          }\n        }))\n        // this.info.project.projectService.reloadProjects()\n        return true\n      }\n    }\n    return false\n  }\n\n  private proxyResolveModuleNames (): void {\n    const originHandler = this.tsLH.resolveModuleNames?.bind(this.tsLH)\n    this.tsLH.resolveModuleNames = (\n      moduleNames: string[],\n      containingFile: string,\n      reusedNames: string[],\n      redirectedReference: ts.ResolvedProjectReference | undefined,\n      options: ts.CompilerOptions, containingSourceFile?: ts.SourceFile\n    ): Array<ts.ResolvedModule | undefined> => {\n      let setAliasSucceed = false\n      // we don't need to handle node_modules\n      if (!containingFile.includes('node_modules')) {\n        this.logger.info(`${LOG_PREFIX} moduleNames, ${moduleNames.join('|')}`)\n        this.logger.info(`${LOG_PREFIX} containingFile, ${containingFile}`)\n        this.logger.info(`${LOG_PREFIX} compilerOptions, ${JSON.stringify(options)}`)\n        this.logger.info(`${LOG_PREFIX} projectpath, ${this.info.project.getCurrentDirectory()}`)\n        setAliasSucceed = this.setResolveAlias()\n        this.logger.info(`${LOG_PREFIX} resolveAlias after, ${JSON.stringify(this.info.project.getCompilerOptions())} setAliasSucceed ${setAliasSucceed}`)\n      }\n      // if set alias succeeed, we need to read new compilerOptions\n      const newOptions = setAliasSucceed ? this.info.project.getCompilerOptions() : options\n      return originHandler?.(moduleNames, containingFile, reusedNames, redirectedReference, newOptions, containingSourceFile) ?? [undefined]\n    }\n  }\n}\n\nexport {\n  MiniProgramTypeScriptLanguageService\n}\n","import * as ts from 'typescript/lib/tsserverlibrary'\n\nclass FSManager {\n  private readonly sys: ts.System\n  constructor (\n    private readonly _ts: typeof ts\n  ) {\n    this.sys = _ts.sys\n  }\n\n  readFile (filePath: string): string | null {\n    if (this.sys.fileExists(filePath)) {\n      return this.sys.readFile(filePath, 'utf8') ?? ''\n    }\n    return null\n  }\n\n  readJSON<T>(filePath: string): T | null {\n    try {\n      let fileContent = this.readFile(filePath)\n      if (fileContent !== null) {\n        fileContent = JSON.parse(fileContent)\n      }\n      return fileContent as T | null\n    } catch (e) {\n      return null\n    }\n  }\n\n  readTSConfig (filePath: string): ITransformedTSConfig['raw'] | null {\n    if (!filePath.endsWith('.json')) {\n      filePath = `${filePath}.json`\n    }\n    const content = this.readFile(filePath)\n    if (content === null) {\n      return null\n    }\n    const res = this._ts.readConfigFile(filePath, this.sys.readFile)\n    if (res.error !== undefined) {\n      return null\n    }\n    return res.config\n  }\n}\n\nexport {\n  FSManager\n}\n","import path = require('path')\n\n/**\n * transform alias to paths rule.\n * eg. { \"@\": \"xxx\" } -> { \"@/*\": [\"xxx/*\"] }\n * @param resolveAlias miniprogram resolveAlias\n */\nexport function transformResolveAliasToPaths (\n  resolveAlias: IAppJSON['resolveAlias'] = {},\n  miniprogramRoot: string, // absolute path\n  baseUrl: string, // absolute path\n  logger: any\n): ITSConfigPaths {\n  const paths: ITSConfigPaths = {}\n  const aliasNames = Object.keys(resolveAlias)\n  aliasNames.forEach(aliasName => {\n    const alias = resolveAlias[aliasName]\n    if (validateAlias(aliasName, alias)) {\n      const aliasAbsolutePath = path.join(miniprogramRoot, alias)\n      const relativeAlias = normalizePath(path.relative(baseUrl, aliasAbsolutePath))\n      paths[aliasName] = [\n        relativeAlias\n      ]\n    }\n  })\n  return paths\n}\n\nfunction validateAlias (aliasName: string, aliasValue: string): boolean {\n  if (aliasName.endsWith('/*') && aliasValue.endsWith('/*')) {\n    return true\n  }\n  if (aliasName.endsWith('*') && aliasValue.endsWith('*')) {\n    return true\n  }\n  return false\n}\n\n// /**\n//  * transform alias to path\n//  * eg. \"xxx\" -> \"xxx/*\"\n//  * @returns\n//  */\n// export function transformAliasToPath (alias: string): string {\n//   if (alias === '' || alias === '*') {\n//     return '*'\n//   }\n//   if (alias.endsWith('/')) {\n//     return `${alias}*`\n//   }\n//   if (alias.endsWith('/*')) {\n//     return alias\n//   }\n//   return `${alias}/*`\n// }\n\n/**\n * if we want to add or set paths, we also need to add or set the following props:\n * 1. baseUrl -> need to absolute path\n * 2. outDir(if is empty) -> need to absolute path\n * 3. pathsBasePath -> need to absolute path, equals project directory\n * 4. projectPath -> current project path\n * @param compilerOptions\n */\nexport function getTSConfigPathsRelativeConfig (compilerOptions: IPathsRelativeOptions, projectPath: string): IPathsRelativeOptions {\n  let { baseUrl = '.', outDir = './dist' } = compilerOptions\n  if (!path.isAbsolute(baseUrl)) {\n    baseUrl = path.join(projectPath, baseUrl)\n  }\n  if (!path.isAbsolute(outDir)) {\n    outDir = path.join(projectPath, outDir)\n  }\n  return {\n    baseUrl: normalizePath(baseUrl),\n    outDir,\n    pathsBasePath: projectPath,\n    projectPath\n  }\n}\n\nexport function getAbsolutePath (filePath: string, baseDir: string): string {\n  if (path.isAbsolute(filePath)) {\n    return filePath\n  }\n  return normalizePath(path.join(baseDir, filePath))\n}\n\n/**\n * \\\\ -> /\n * @param path\n */\nexport function normalizePath (path: string): string {\n  return path.replace(/\\\\/g, '/')\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["tsConfigMap","Map","modules","ts","typescript","getDefaultCompilerOptions","allowJs","noEmit","create","info","fsManager","FSManager","logger","project","projectService","languageService","languageServiceHost","fs","currentTSConfigPath","normalizePath","path","join","getCurrentDirectory","has","tsConfig","readTSConfig","set","raw","getRawTSConfig","miniProgramTypeScriptLanguageService","MiniProgramTypeScriptLanguageService","init","setResolveAlias","LOG_PREFIX","constructor","tsLS","tsLH","_ts","this","proxyResolveModuleNames","getTransformedTSConfigPaths","tsConfigPath","currentProjectPath","dirname","parentPaths","baseUrl","outDir","pathsBasePath","projectPath","undefined","get","paths","extends","res","compilerOptions","getAbsolutePath","currentTSConfigPaths","projectConfigPath","projectConfig","readJSON","realMiniprogramRoot","srcMiniprogramRoot","miniprogramRoot","realAppJSONPath","appJSON","resolveAlias","originCompilerOptions","getCompilerOptions","tsConfigPaths","JSON","stringify","pathsRelativeConfig","getTSConfigPathsRelativeConfig","transformResolveAliasToPaths","setCompilerOptionsForInferredProjects","setCompilerOptions","Object","assign","originHandler","resolveModuleNames","bind","moduleNames","containingFile","reusedNames","redirectedReference","options","containingSourceFile","setAliasSucceed","includes","newOptions","sys","readFile","filePath","fileExists","fileContent","parse","e","endsWith","readConfigFile","error","config","replace","keys","forEach","aliasName","alias","aliasValue","validateAlias","aliasAbsolutePath","relativeAlias","relative","isAbsolute","baseDir","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}